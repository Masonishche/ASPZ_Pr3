# Звіт по практичній роботі №3: Дослідження обмежень ресурсів у середовищі FreeBSD
## Мета роботи:
Ознайомитися з механізмами обмеження ресурсів у середовищі FreeBSD, дослідити вплив обмежень на поведінку програм, навчитися писати програми, які враховують ці обмеження.

## Завдання 3.1 — Обмеження кількості відкритих файлів (ulimit -n)
### Теоретичне пояснення:
У FreeBSD кожен процес має обмеження на кількість одночасно відкритих файлів. Це обмеження можна переглянути або змінити за допомогою:


Також можна переглянути всі обмеження:


### Що відбувається:
Якщо процес перевищує ліміт, він не зможе відкривати нові файли або сокети.
Це критично для серверів або програм, які працюють з великою кількістю файлів.

![Знімок екрана 2025-06-05 135807](https://github.com/user-attachments/assets/2567642b-5092-4c31-b8a3-5a8b98512039)

## Завдання 3.2 — Встановлення утиліти perf (або аналогів) і тестування ліміту
### Теоретичне пояснення:
У FreeBSD perf не використовується. Замість нього застосовують:

dtrace — потужна система трасування.
pmcstat — для збору статистики продуктивності.
top, procstat, ktrace — для моніторингу процесів.
Що відбувається:
Ви запускаєте програму, яка споживає ресурси.
Система може обмежити її через ulimit, rctl, або login.conf.
Ви спостерігаєте, як обмеження впливають на виконання.

## Завдання 3.3 — Імітація кидання кубика з обмеженням на розмір файлу
### Суть завдання:
Необхідно створити програму, яка імітує кидання шестигранного кубика (тобто генерацію випадкових чисел від 1 до 6) та записує результати у файл. Перед запуском програми потрібно встановити обмеження на максимальний розмір файлу (через ulimit -f). Програма має коректно обробляти ситуацію, коли розмір файлу перевищує встановлений ліміт.

### Мета завдання:
Ознайомитися з обмеженням ресурсу file size.
Навчитися обробляти помилки, пов’язані з перевищенням системних лімітів.
Побачити, як система реагує на спробу запису у файл, коли досягнуто межі дозволеного розміру.

### Код програми
(https://github.com/Masonishche/ASPZ_Pr3/blob/main/task3.c)

### Опис рішення:
Генерація випадкових чисел:

Використовується функція rand() для генерації чисел від 1 до 6.
srand(time(NULL)) ініціалізує генератор випадкових чисел.
Запис у файл:

Відкривається файл dice.txt у режимі запису.
У циклі записуються результати кидків у файл.
Обмеження на розмір файлу:

Перед запуском програми виконується команда:

    ulimit -f 10

Це обмежує розмір файлу до 10 блоків по 512 байт (тобто 5120 байт ≈ 5 КБ).
Обробка помилки:

Якщо під час запису виникає помилка (через досягнення ліміту), fprintf повертає від’ємне значення.
У цьому випадку викликається perror() для виводу повідомлення про помилку.
### Приклад виконання :

![Знімок екрана 2025-06-05 141030](https://github.com/user-attachments/assets/4ad2c188-1bf3-47ef-80f7-7c2f51f2cf2a)

На зображенні видно:

Програма компілюється (cc task3.c -o task3).
Запускається без обмежень — нічого не виводить, бо файл створюється нормально.
Встановлюється обмеження:

    ulimit -f 10

Повторний запуск призводить до помилки:

    Filesize limit exceeded
Це означає, що програма намагалась записати більше, ніж дозволено (5 КБ), і система її зупинила.

## Завдання 3.4 — Лотерея з обмеженням на час ЦП
### Суть завдання:
Реалізувати програму, яка імітує лотерею:

Генерує 7 різних чисел з діапазону 1–49.
Генерує 6 різних чисел з діапазону 1–36.
Перед запуском встановлюється обмеження на максимальний час використання процесором (ulimit -t).
Програма має демонструвати, як система обмежує виконання при перевищенні цього ліміту.
### Мета завдання:
Ознайомитися з обмеженням ресурсу CPU time.
Побачити, як система припиняє виконання процесу при перевищенні дозволеного часу.
Навчитися писати нескінченні або довготривалі обчислення, які можуть бути обмежені системою.

### Код програми 
(https://github.com/Masonishche/ASPZ_Pr3/blob/main/task4.c)

### Опис рішення:
Генерація чисел:

Програма використовує генератор випадкових чисел rand() для вибору чисел.
Для унікальності чисел використовується масив, який відмічає вже вибрані значення.
Нескінченний цикл:

Програма постійно генерує нові комбінації чисел у нескінченному циклі while (1).
Це дозволяє перевірити, як система обмежує час виконання.
Обмеження часу:

Перед запуском встановлюється обмеження:

    ulimit -t 5

Це означає, що процес може використовувати лише 5 секунд процесорного часу.

Результат:

![Знімок екрана 2025-06-05 163002](https://github.com/user-attachments/assets/df8abf6b-9553-4c02-9580-4a25098e12d7)

Програма починає працювати, але через кілька секунд система автоматично її завершує.
Це демонструє, як працює обмеження ulimit -t.

## Завдання 3.5 — Копіювання файлів з перевірками
### Суть завдання:
Написати програму, яка копіює вміст одного файлу в інший. Програма має:

Перевіряти, чи передано два аргументи.
Перевіряти, чи доступний перший файл для читання.
Перевіряти, чи доступний другий файл для запису.
Обробляти ситуацію, коли перевищено обмеження на розмір файлу (ulimit -f).
### Опис рішення:
Програма перевіряє кількість аргументів.
Відкриває файли з перевіркою на помилки.
Копіює вміст блоками.
Якщо під час запису виникає помилка — виводить повідомлення.

## Завдання 3.5 — Копіювання файлів з перевірками
### Суть завдання:
Реалізувати програму, яка копіює вміст одного іменованого файлу в інший. Програма повинна:

Приймати два аргументи командного рядка — імена файлів.
Перевіряти:
Чи передано рівно два аргументи.
Чи доступний перший файл для читання.
Чи можна створити або відкрити другий файл для запису.
Обробляти ситуацію, коли під час запису перевищено обмеження на розмір файлу (через ulimit -f).
### Мета завдання:
Навчитися працювати з аргументами командного рядка.
Освоїти базову роботу з файлами у мові C.
Ознайомитися з обробкою помилок введення/виведення.
Побачити, як системні обмеження (наприклад, розмір файлу) впливають на виконання програм.
### Пояснення логіки програми:
Програма призначена для копіювання вмісту одного файлу в інший. Вона запускається з двома аргументами — іменами файлів: перший файл є джерелом (його вміст читається), а другий — приймачем (у нього записується копія).

Перевірка аргументів командного рядка:

Програма перевіряє, чи передано рівно два аргументи.
Якщо аргументів менше або більше, вона виводить повідомлення:

      Program need two arguments
      
і завершує роботу.
Спроба відкрити вхідний файл для читання:

Програма намагається відкрити перший файл у режимі читання ("r").
Якщо файл не існує або немає прав доступу, виводиться повідомлення:

    Cannot open file <ім’я> for reading

Спроба відкрити вихідний файл для запису:

Програма намагається створити або відкрити другий файл у режимі запису ("w").
Якщо файл не вдається відкрити (наприклад, немає прав на створення), виводиться повідомлення:

    Cannot open file <ім’я> for writing

Копіювання вмісту:

Програма читає вміст вхідного файлу блоками по 1024 байти.
Кожен блок записується у вихідний файл.
Якщо під час запису виникає помилка (наприклад, через перевищення обмеження на розмір файлу), програма виводить повідомлення:

    Write error (possibly file size limit reached)

Завершення роботи:

Після завершення копіювання або при виникненні помилки, обидва файли закриваються.
Програма завершує роботу.
Завжди закривай файли після завершення роботи з ними.
### Код програми:

https://github.com/Masonishche/ASPZ_Pr3/blob/main/task5.c

### Інструкція до запуску:

![Знімок екрана 2025-06-05 165111](https://github.com/user-attachments/assets/f5b96e39-c446-49fa-9dcb-e37728cf8f92)

## Завдання 3.6 — Демонстрація використання обмеження на розмір стеку (max stack segment size)
### Суть завдання:
Написати програму, яка демонструє, як працює обмеження на розмір стеку процесу. Для цього потрібно створити рекурсивну програму, оскільки кожен виклик функції в рекурсії використовує частину стеку. При досягненні межі стеку програма має аварійно завершитися (наприклад, через Segmentation fault).

### Мета завдання:
Ознайомитися з обмеженням ресурсу stack size.
Побачити, як система реагує на перевищення цього обмеження.
Навчитися писати рекурсивні функції та аналізувати їх вплив на пам’ять.
### Опис рішення:
Рекурсивна функція:

Створюється функція, яка викликає саму себе без зупинки (або до певної глибини).
Кожен виклик займає місце у стеку.


Перед запуском встановлюється обмеження:

    ulimit -s 64

Це обмежує стек до 64 КБ.

Очікувана поведінка:

Програма викликає функцію багато разів.
При досягненні межі стеку система завершує процес з помилкою Segmentation fault.
### Код програми:
(https://github.com/Masonishche/ASPZ_Pr3/blob/main/task6.c)

### Результат:
![Знімок екрана 2025-06-05 171507](https://github.com/user-attachments/assets/01f54820-68ee-461c-aa63-dec9dd91a54a)

![Знімок екрана 2025-06-05 171525](https://github.com/user-attachments/assets/99ec1c94-9873-423d-9641-b7fad3a3a1e4)

## Завдання 23 (за варіантом):
Написати програму, яка тестує різні методи обмеження ресурсів у Linux.

### Суть завдання:
Метою цього завдання є створення програми, яка на практиці демонструє, як саме працюють механізми обмеження ресурсів у Linux-системі, зокрема через команду ulimit. Програма повинна запускати окремі перевірки для різних типів ресурсів: максимальний розмір файлу, використання процесора, кількість відкритих файлів, об’єм доступної пам’яті, розмір стеку тощо. Це дозволяє проаналізувати реакцію системи на перевищення встановлених лімітів та дослідити, як вона захищає себе від надмірного споживання ресурсів окремими процесами.

### Код програми:
(https://github.com/Masonishche/ASPZ_Pr3/blob/main/task23.c)

### Опис реалізації:
Для реалізації було створено програму мовою С, яка виконує послідовно кілька тестів. Кожен тест запускається в окремому дочірньому процесі, що дозволяє уникнути впливу одного ресурсу на інші та дозволяє системі ізолювати наслідки перевищення обмежень. Програма тестує наступне:

Обмеження часу процесора (CPU time limit) – запускається нескінченний цикл, який перевантажує процесор.

Обмеження розміру файлу (file size limit) – у файл записується великий обсяг даних до перевищення дозволеного розміру.

Обмеження пам’яті (virtual memory limit) – виділяється багато оперативної пам’яті у циклі, поки система не припиняє виділення.

Обмеження на розмір стеку (stack size limit) – використовується рекурсивна функція, що споживає стек до його вичерпання.

Обмеження на кількість відкритих файлів (open files limit) – програма намагається відкрити якомога більше файлів одночасно.

Перед запуском програми ліміти можна встановити вручну через ulimit у терміналі. Наприклад:
ulimit -t 1, ulimit -f 100, ulimit -n 32, ulimit -s 512, ulimit -v 65536 тощо.

Компіляція відбувалася за допомогою компілятора cc у середовищі FreeBSD. Програма написана англійською мовою без коментарів відповідно до вимог.

### Аналіз результатів:

![Знімок екрана 2025-06-05 181644](https://github.com/user-attachments/assets/932c5348-2832-4177-85e1-88d1577e0398)

У ході виконання програми було зафіксовано, що при перевищенні певних обмежень система реагує по-різному. Наприклад, коли перевищується ліміт часу процесора, система автоматично надсилає сигнал SIGXCPU, після чого процес припиняється. У разі перевищення розміру файлу функція write() повертає помилку, а система повідомляє про неможливість запису. При надмірному виділенні пам’яті програма отримує malloc-помилку, і виконання переривається. У випадку з рекурсією — при досягненні межі стеку виникає помилка типу Segmentation fault або Bus error. Це також було продемонстровано на скріншоті, де під час компіляції з обмеженням ресурсів система повідомила про помилку Bus error (core dumped).

Таким чином, це завдання дозволило на практиці дослідити, як система Linux/FreeBSD захищає себе від нестабільних програм, які можуть порушити її роботу через надмірне споживання ресурсів. Також було продемонстровано, що правильне обмеження ресурсів може запобігти аварійним завершенням, збоїв і нестабільності системи. Це особливо важливо для роботи в середовищах з високим навантаженням, наприклад, на сервері або в Docker-контейнері.

### Висновок:

Виконане завдання поглиблює розуміння принципів роботи операційної системи щодо керування ресурсами. Створена програма є універсальним інструментом для дослідження і навчання, а її запуск в різних умовах дозволяє дослідити вплив різних обмежень на стабільність та безпечність виконання коду. Це знання є ключовим для системного програмування, адміністрування серверів і розробки програмного забезпечення, яке працює у контрольованому ресурсному середовищі.

